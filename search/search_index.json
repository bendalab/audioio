{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AudioIO Platform independent interfacing of numpy arrays of floats with audio files and devices for scientific data analysis. Features Audio data are always numpy arrays of floats with values ranging between -1 and 1 independent of how the data are stored in an audio file. load_audio() function for loading data of a whole audio file at once. Blockwise, random-access loading of large or sequential audio files ( class AudioLoader based on class BufferedArray ). Read arbitrary metadata() as nested dictionaries of key-value pairs. Supported RIFF chunks are INFO lists , BEXT , iXML , and GUANO . Read markers() , i.e. cue points with spans, labels, and descriptions. write_audio() function for writing data, metadata, and markers to an audio file. Platform independent, synchronous (blocking) and asynchronous (non blocking) playback of numpy arrays via play() with automatic resampling to match supported sampling rates. Full pathlib support. Detailed and platform specific installation instructions (pip, conda, Debian and RPM based Linux packages, homebrew for MacOS) for all supported audio packages (see audiomodules ). The AudioIO modules try to use whatever audio packages are installed on your system to achieve their tasks. AudioIO, however, adds own code for handling metadata and marker lists. Installation AudioIO is available at PyPi . Simply run: pip install audioio Then you can use already installed audio packages for reading and writing audio files and for playing audio data. However, audio file formats supported by the python standard library are limited to basic wave files and playback capabilities are poor. If you need support for additional audio file formats or proper sound output, you need to install additional packages. See installation for further instructions and recommendations on additional audio packages. Usage information. import audioio as aio Loading audio data Load an audio file into a numpy array using load_audio() : data, samplingrate = aio.load_audio('audio/file.wav') The read in data are always numpy arrays of floats ranging between -1 and 1. The arrays are always 2-D arrays with first axis time and second axis channel, even for single channel data. Plot the first channel: import numpy as np import matplotlib.pyplot as plt time = np.arange(len(data))/samplingrate plt.plot(time, data[:,0]) plt.show() Get a nested dictionary with key-value pairs of the file's metadata and print it using metadata() and print_metadata() : md = aio.metadata('audio/file.wav') aio.print_metadata(md) See the audiometadata module for functions to read, write, and change metadata of various types. Get and print marker positions, spans, labels and texts using markers() and print_markers() : locs, labels = aio.markers('audio/file.wav') aio.print_markers(locs, labels) You can also randomly access chunks of data of an audio file, without loading the entire file into memory, by means of the AudioLoader class . This is really handy for analysing very long sound recordings: # open audio file with a buffer holding 60 seconds of data: with aio.AudioLoader('audio/file.wav', 60.0) as data: block = 1000 rate = data.samplerate for i in range(len(data)//block): x = data[i*block:(i+1)*block] # ... do something with x and rate Instead of a single audio file it can also handle recordings that are split over many files. Just pass all these files as a list to the AudioLoader class . Even simpler, iterate in blocks over the file with overlap using the blocks() generator : from scipy.signal import spectrogram nfft = 2048 with aio.AudioLoader('some/audio.wav') as data: for x in data.blocks(100*nfft, nfft//2): f, t, Sxx = spectrogram(x, nperseg=nfft, noverlap=nfft//2) Metadata and markers can be accessed by the metadata() and markers() member functions of the AudioLoader object: with aio.AudioLoader('audio/file.wav', 60.0) as data: md = data.metadata() locs, labels = data.markers() See API documentation of the audioloader , audiometadata , and audiomarkers modules for details. Writing audio data Write a 1-D or 2-D numpy array into an audio file (data values between -1 and 1) using the write_audio() function: aio.write_audio('audio/file.wav', data, samplerate) Again, in 2-D arrays the first axis (rows) is time and the second axis the channel (columns). Metadata in form of a nested dictionary with key-value pairs, marker positions and spans ( locs ) as well as associated labels and texts ( labels ) can also be passed on to the write_audio() function: aio.write_audio('audio/file.wav', data, samplerate, md, locs, labels) See API documentation of the audiowriter module for details. Converting audio files AudioIO provides a command line script for converting, downsampling, renaming and merging audio files: > audioconverter -e float -o test.wav test.mp3 If possible, audioconverter tries to keep metadata and marker lists. See documentation of the audioconverter module for details. Display metadata and markers AudioIO provides a command line script that prints metadata and markers of audio files to the console: > audiometadata test.wav See documentation of the audiometadata module for details. Fixing time stamps AudioIO provides a command line script for fixing time stamps in the metadata and file names of audio files. This is useful in case the real-time clock of a recorder failed. Let's assume you have a continous recording spread over the following four files each covering 3 minutes of the recording: logger-20190101T000015.wav logger-20190101T000315.wav logger-20190101T000615.wav logger-20190101T000915.wav However, the recording was actually started at 2025-06-09T10:42:17. Obviously, the real-time clock failed, since all times in the file name and the time stamps in the metadata start in the year 2019. To fix this, run > fixtimestamps -s '2025-06-09T10:42:17' logger-2019*.wav Then the files are renamed: logger-20190101T000015.wav -> logger-20250609T104217.wav logger-20190101T000315.wav -> logger-20250609T104517.wav logger-20190101T000615.wav -> logger-20250609T104817.wav logger-20190101T000915.wav -> logger-20250609T105117.wav and the time stamps in the meta data are set accordingly. See documentation of the fixtimestamps module for details. Playing sounds Fade in and out ( fade() ) and play ( play() ) a 1-D or 2-D numpy array as a sound (first axis is time and second axis the channel): aio.fade(data, samplingrate, 0.2) aio.play(data, samplingrate) Just beep() aio.beep() Beep for half a second and 440 Hz: aio.beep(0.5, 440.0) aio.beep(0.5, 'a4') Musical notes are translated into frequency with the note2freq() function. See API documentation of the playaudio module for details. Managing audio modules Simply run in your terminal > audiomodules and you get something like Status of audio packages on this machine: ----------------------------------------- wave is installed (F) ewave not installed (F) scipy.io.wavfile is installed (F) soundfile is installed (F) wavefile not installed (F) audioread is installed (F) pydub is installed (F) pyaudio not installed (D) sounddevice NOT installed (D) simpleaudio not installed (D) soundcard not installed (D) ossaudiodev is installed (D) winsound not installed (D) F: file I/O, D: audio device For better performance you should install the following modules: sounddevice: ------------ The sounddevice package is a wrapper of the portaudio library (http://www.portaudio.com). For documentation see https://python-sounddevice.readthedocs.io First, install the following packages: sudo apt install libportaudio2 portaudio19-dev python3-cffi Install the sounddevice module with pip: sudo pip install sounddevice Use this to see which audio modules you have already installed on your system, which ones are recommended to install, and how to install them. See API documentation of the audiomodules module for details. Used by thunderlab : Load and preprocess time series data. thunderfish : Algorithms and programs for analysing electric field recordings of weakly electric fish. audian : Python-based GUI for viewing and analyzing recordings of animal vocalizations. Alternatives All the audio modules AudioIO is using. Reading and writing audio files: wave : simple wave file interface of the python standard library. ewave : extended wave files. scipy.io.wavfile : simple scipy wave file interface. SoundFile : support of many open source audio file formats via libsndfile . wavefile : support of many open source audio file formats via libsndfile . audioread : mpeg file support. Pydub : mpeg support for reading and writing, playback via simlpeaudio or pyaudio. scikits.audiolab : seems to be no longer active. Metadata: GUANO : Grand Unified Acoustic Notation Ontology, an extensible, open format for embedding metadata within bat acoustic recordings. Playing sounds: sounddevice : wrapper for portaudio . PyAudio : wrapper for portaudio . simpleaudio : uses ALSA on Linux, runs well on windows. SoundCard : playback via CFFI and the native audio libraries of Linux, Windows and macOS. ossaudiodev : playback via the outdated OSS interface of the python standard library. winsound : native windows audio playback of the python standard library, asynchronous playback only with wave files. Not yet supported by audioio: mutagen : handles audio metadata of many audio file formats. playsound : pure Python, cross platform, single function module with no dependencies for playing sounds. Plays sounds from files only. PreferredSoundPlayer : Platfrom independt playing of sound files. AudioPlayer : cross platform Python 3 package for playing sounds (mp3, wav, ...). Scientific audio software: diapason : musical notes like playaudio.note2freq . librosa : audio and music processing in python. TimeView : GUI application to view and analyze time series signal data. scikit-maad : quantitative analysis of environmental audio recordings Soundscapy : analysing and visualising soundscape assessments. BatDetect2 : detecting and classifying bat echolocation calls in high frequency audio recordings. Batogram : viewing bat call spectrograms with GUANO metadata , including the ability to click to open the location in Google Maps.","title":"Home"},{"location":"#audioio","text":"Platform independent interfacing of numpy arrays of floats with audio files and devices for scientific data analysis.","title":"AudioIO"},{"location":"#features","text":"Audio data are always numpy arrays of floats with values ranging between -1 and 1 independent of how the data are stored in an audio file. load_audio() function for loading data of a whole audio file at once. Blockwise, random-access loading of large or sequential audio files ( class AudioLoader based on class BufferedArray ). Read arbitrary metadata() as nested dictionaries of key-value pairs. Supported RIFF chunks are INFO lists , BEXT , iXML , and GUANO . Read markers() , i.e. cue points with spans, labels, and descriptions. write_audio() function for writing data, metadata, and markers to an audio file. Platform independent, synchronous (blocking) and asynchronous (non blocking) playback of numpy arrays via play() with automatic resampling to match supported sampling rates. Full pathlib support. Detailed and platform specific installation instructions (pip, conda, Debian and RPM based Linux packages, homebrew for MacOS) for all supported audio packages (see audiomodules ). The AudioIO modules try to use whatever audio packages are installed on your system to achieve their tasks. AudioIO, however, adds own code for handling metadata and marker lists.","title":"Features"},{"location":"#installation","text":"AudioIO is available at PyPi . Simply run: pip install audioio Then you can use already installed audio packages for reading and writing audio files and for playing audio data. However, audio file formats supported by the python standard library are limited to basic wave files and playback capabilities are poor. If you need support for additional audio file formats or proper sound output, you need to install additional packages. See installation for further instructions and recommendations on additional audio packages.","title":"Installation"},{"location":"#usage","text":"information. import audioio as aio","title":"Usage"},{"location":"#loading-audio-data","text":"Load an audio file into a numpy array using load_audio() : data, samplingrate = aio.load_audio('audio/file.wav') The read in data are always numpy arrays of floats ranging between -1 and 1. The arrays are always 2-D arrays with first axis time and second axis channel, even for single channel data. Plot the first channel: import numpy as np import matplotlib.pyplot as plt time = np.arange(len(data))/samplingrate plt.plot(time, data[:,0]) plt.show() Get a nested dictionary with key-value pairs of the file's metadata and print it using metadata() and print_metadata() : md = aio.metadata('audio/file.wav') aio.print_metadata(md) See the audiometadata module for functions to read, write, and change metadata of various types. Get and print marker positions, spans, labels and texts using markers() and print_markers() : locs, labels = aio.markers('audio/file.wav') aio.print_markers(locs, labels) You can also randomly access chunks of data of an audio file, without loading the entire file into memory, by means of the AudioLoader class . This is really handy for analysing very long sound recordings: # open audio file with a buffer holding 60 seconds of data: with aio.AudioLoader('audio/file.wav', 60.0) as data: block = 1000 rate = data.samplerate for i in range(len(data)//block): x = data[i*block:(i+1)*block] # ... do something with x and rate Instead of a single audio file it can also handle recordings that are split over many files. Just pass all these files as a list to the AudioLoader class . Even simpler, iterate in blocks over the file with overlap using the blocks() generator : from scipy.signal import spectrogram nfft = 2048 with aio.AudioLoader('some/audio.wav') as data: for x in data.blocks(100*nfft, nfft//2): f, t, Sxx = spectrogram(x, nperseg=nfft, noverlap=nfft//2) Metadata and markers can be accessed by the metadata() and markers() member functions of the AudioLoader object: with aio.AudioLoader('audio/file.wav', 60.0) as data: md = data.metadata() locs, labels = data.markers() See API documentation of the audioloader , audiometadata , and audiomarkers modules for details.","title":"Loading audio data"},{"location":"#writing-audio-data","text":"Write a 1-D or 2-D numpy array into an audio file (data values between -1 and 1) using the write_audio() function: aio.write_audio('audio/file.wav', data, samplerate) Again, in 2-D arrays the first axis (rows) is time and the second axis the channel (columns). Metadata in form of a nested dictionary with key-value pairs, marker positions and spans ( locs ) as well as associated labels and texts ( labels ) can also be passed on to the write_audio() function: aio.write_audio('audio/file.wav', data, samplerate, md, locs, labels) See API documentation of the audiowriter module for details.","title":"Writing audio data"},{"location":"#converting-audio-files","text":"AudioIO provides a command line script for converting, downsampling, renaming and merging audio files: > audioconverter -e float -o test.wav test.mp3 If possible, audioconverter tries to keep metadata and marker lists. See documentation of the audioconverter module for details.","title":"Converting audio files"},{"location":"#display-metadata-and-markers","text":"AudioIO provides a command line script that prints metadata and markers of audio files to the console: > audiometadata test.wav See documentation of the audiometadata module for details.","title":"Display metadata and markers"},{"location":"#fixing-time-stamps","text":"AudioIO provides a command line script for fixing time stamps in the metadata and file names of audio files. This is useful in case the real-time clock of a recorder failed. Let's assume you have a continous recording spread over the following four files each covering 3 minutes of the recording: logger-20190101T000015.wav logger-20190101T000315.wav logger-20190101T000615.wav logger-20190101T000915.wav However, the recording was actually started at 2025-06-09T10:42:17. Obviously, the real-time clock failed, since all times in the file name and the time stamps in the metadata start in the year 2019. To fix this, run > fixtimestamps -s '2025-06-09T10:42:17' logger-2019*.wav Then the files are renamed: logger-20190101T000015.wav -> logger-20250609T104217.wav logger-20190101T000315.wav -> logger-20250609T104517.wav logger-20190101T000615.wav -> logger-20250609T104817.wav logger-20190101T000915.wav -> logger-20250609T105117.wav and the time stamps in the meta data are set accordingly. See documentation of the fixtimestamps module for details.","title":"Fixing time stamps"},{"location":"#playing-sounds","text":"Fade in and out ( fade() ) and play ( play() ) a 1-D or 2-D numpy array as a sound (first axis is time and second axis the channel): aio.fade(data, samplingrate, 0.2) aio.play(data, samplingrate) Just beep() aio.beep() Beep for half a second and 440 Hz: aio.beep(0.5, 440.0) aio.beep(0.5, 'a4') Musical notes are translated into frequency with the note2freq() function. See API documentation of the playaudio module for details.","title":"Playing sounds"},{"location":"#managing-audio-modules","text":"Simply run in your terminal > audiomodules and you get something like Status of audio packages on this machine: ----------------------------------------- wave is installed (F) ewave not installed (F) scipy.io.wavfile is installed (F) soundfile is installed (F) wavefile not installed (F) audioread is installed (F) pydub is installed (F) pyaudio not installed (D) sounddevice NOT installed (D) simpleaudio not installed (D) soundcard not installed (D) ossaudiodev is installed (D) winsound not installed (D) F: file I/O, D: audio device For better performance you should install the following modules: sounddevice: ------------ The sounddevice package is a wrapper of the portaudio library (http://www.portaudio.com). For documentation see https://python-sounddevice.readthedocs.io First, install the following packages: sudo apt install libportaudio2 portaudio19-dev python3-cffi Install the sounddevice module with pip: sudo pip install sounddevice Use this to see which audio modules you have already installed on your system, which ones are recommended to install, and how to install them. See API documentation of the audiomodules module for details.","title":"Managing audio modules"},{"location":"#used-by","text":"thunderlab : Load and preprocess time series data. thunderfish : Algorithms and programs for analysing electric field recordings of weakly electric fish. audian : Python-based GUI for viewing and analyzing recordings of animal vocalizations.","title":"Used by"},{"location":"#alternatives","text":"All the audio modules AudioIO is using. Reading and writing audio files: wave : simple wave file interface of the python standard library. ewave : extended wave files. scipy.io.wavfile : simple scipy wave file interface. SoundFile : support of many open source audio file formats via libsndfile . wavefile : support of many open source audio file formats via libsndfile . audioread : mpeg file support. Pydub : mpeg support for reading and writing, playback via simlpeaudio or pyaudio. scikits.audiolab : seems to be no longer active. Metadata: GUANO : Grand Unified Acoustic Notation Ontology, an extensible, open format for embedding metadata within bat acoustic recordings. Playing sounds: sounddevice : wrapper for portaudio . PyAudio : wrapper for portaudio . simpleaudio : uses ALSA on Linux, runs well on windows. SoundCard : playback via CFFI and the native audio libraries of Linux, Windows and macOS. ossaudiodev : playback via the outdated OSS interface of the python standard library. winsound : native windows audio playback of the python standard library, asynchronous playback only with wave files. Not yet supported by audioio: mutagen : handles audio metadata of many audio file formats. playsound : pure Python, cross platform, single function module with no dependencies for playing sounds. Plays sounds from files only. PreferredSoundPlayer : Platfrom independt playing of sound files. AudioPlayer : cross platform Python 3 package for playing sounds (mp3, wav, ...). Scientific audio software: diapason : musical notes like playaudio.note2freq . librosa : audio and music processing in python. TimeView : GUI application to view and analyze time series signal data. scikit-maad : quantitative analysis of environmental audio recordings Soundscapy : analysing and visualising soundscape assessments. BatDetect2 : detecting and classifying bat echolocation calls in high frequency audio recordings. Batogram : viewing bat call spectrograms with GUANO metadata , including the ability to click to open the location in Google Maps.","title":"Alternatives"},{"location":"installation/","text":"Installation AudioIO does not provide own code but rather uses whatever audio modules are installed on your system. The python standard library support for reading and writing audio files and for playing sound is rather poor. You certainly want to install additional packages for better performance. Run in your terminal > audiomodules to see which audio modules you have already installed on your system, which ones are recommended to install, and how to install them. By calling the script with the name of an audio module as an argument you get platform specific installation instructions for this module. E.g. > audiomodules soundfile Recommendations For accessing a wide range of open source audio file formats install sndfile library and the python wrapper SoundFile . MPEG and similar formats are supported by libav (https://libav.org) and ffmpeg (https://ffmpeg.org/) via audioread for reading and Pydub for writing. For playing sounds, use the sounddevice package, that is based on portaudio . Unfortunately, the simple but powerful simpleaudio package is no longer maintained. For details, call audiomodules soundfile audiomodules audioread audiomodules pydub audiomodules sounddevice Here is how to install all these packages at once: Debian-based Linux sudo apt install libsndfile1 libsndfile1-dev libffi-dev sudo pip install SoundFile sudo apt install ffmpeg python3-audioread python3-pydub sudo apt install libportaudio2 portaudio19-dev python3-cffi sudo pip install sounddevice Fedora-based Linux dnf install libsndfile libsndfile-devel libffi-devel pip install SoundFile dnf install ffmpeg ffmpeg-devel python3-audioread python3-pydub dnf install libportaudio portaudio-devel python3-cffi pip install sounddevie Windows pip install SoundFile pip install sounddevice","title":"Installation"},{"location":"installation/#installation","text":"AudioIO does not provide own code but rather uses whatever audio modules are installed on your system. The python standard library support for reading and writing audio files and for playing sound is rather poor. You certainly want to install additional packages for better performance. Run in your terminal > audiomodules to see which audio modules you have already installed on your system, which ones are recommended to install, and how to install them. By calling the script with the name of an audio module as an argument you get platform specific installation instructions for this module. E.g. > audiomodules soundfile","title":"Installation"},{"location":"installation/#recommendations","text":"For accessing a wide range of open source audio file formats install sndfile library and the python wrapper SoundFile . MPEG and similar formats are supported by libav (https://libav.org) and ffmpeg (https://ffmpeg.org/) via audioread for reading and Pydub for writing. For playing sounds, use the sounddevice package, that is based on portaudio . Unfortunately, the simple but powerful simpleaudio package is no longer maintained. For details, call audiomodules soundfile audiomodules audioread audiomodules pydub audiomodules sounddevice Here is how to install all these packages at once:","title":"Recommendations"},{"location":"installation/#debian-based-linux","text":"sudo apt install libsndfile1 libsndfile1-dev libffi-dev sudo pip install SoundFile sudo apt install ffmpeg python3-audioread python3-pydub sudo apt install libportaudio2 portaudio19-dev python3-cffi sudo pip install sounddevice","title":"Debian-based Linux"},{"location":"installation/#fedora-based-linux","text":"dnf install libsndfile libsndfile-devel libffi-devel pip install SoundFile dnf install ffmpeg ffmpeg-devel python3-audioread python3-pydub dnf install libportaudio portaudio-devel python3-cffi pip install sounddevie","title":"Fedora-based Linux"},{"location":"installation/#windows","text":"pip install SoundFile pip install sounddevice","title":"Windows"}]}